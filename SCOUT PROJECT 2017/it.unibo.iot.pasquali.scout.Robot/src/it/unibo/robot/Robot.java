/* Generated by AN DISI Unibo */ 
package it.unibo.robot;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import alice.tuprolog.Term;
import it.unibo.contactEvent.interfaces.IEventItem;
import it.unibo.domain.model.implementation.State;
import it.unibo.domain.model.map.Map;
import it.unibo.iot.configurator.Configurator;
import it.unibo.iot.models.sensorData.SensorType;
import it.unibo.iot.models.sensorData.distance.IDistanceSensorData;
import it.unibo.iot.sensors.ISensor;
import it.unibo.iot.sensors.distanceSensor.DistanceSensor;
import it.unibo.is.interfaces.IOutputEnvView;
import it.unibo.planning.astar.domain.Move;
import it.unibo.planning.enums.Direction;
import it.unibo.planning.enums.ForwardMoveType;
import it.unibo.planning.enums.MoveType;
import it.unibo.planning.enums.SpinDirection;
import it.unibo.qactors.action.AsynchActionResult;
import it.unibo.qactors.action.IActorAction.ActionExecMode;
import it.unibo.qactors.akka.QActorPlanUtils;
import it.unibo.robot.exputils.*;
import it.unibo.robot.exputils.algo.Explorer;
import it.unibo.robot.planutils.*;
import it.unibo.qactors.QActorContext;

//
public class Robot extends AbstractRobot { 
	
	private int defaultSpeed, defaultTime;
	private int defaultTurnSpeed, defaultTurnTime;
	
	private Map map;
	private ArrayList<State> path;
	
	private State position, goal;
	private Direction direction;
	int spinFactor = 1;
	
	private Engine engine = null;	
	
	
	private HashMap<String, Move> moveMapping;
	private HashMap<Integer, Direction> spinMap;
	
	
	public Robot(String actorId, QActorContext myCtx, IOutputEnvView outEnvView ) throws Exception
	{
		super(actorId,myCtx,outEnvView ,it.unibo.qactors.QActorUtils.robotBase );
		
		QActorPlanUtils myUtils = new QActorPlanUtilsDebug(this, actionUtils, outEnvView);
		
		this.planUtils = myUtils;
		
		this.moveMapping = new HashMap<String, Move>();
		moveMapping.put("forwardN", new Move(ForwardMoveType.TILED));
		moveMapping.put("forwardE", new Move(ForwardMoveType.TILED));
		moveMapping.put("forwardW", new Move(ForwardMoveType.TILED));
		moveMapping.put("forwardS", new Move(ForwardMoveType.TILED));
		moveMapping.put("forwardNE", new Move(ForwardMoveType.DIAGONAL));
		moveMapping.put("forwardNW", new Move(ForwardMoveType.DIAGONAL));
		moveMapping.put("forwardSE", new Move(ForwardMoveType.DIAGONAL));
		moveMapping.put("forwardSW", new Move(ForwardMoveType.DIAGONAL));
		moveMapping.put("leftN", new Move(SpinDirection.LEFT));
		moveMapping.put("leftNE", new Move(SpinDirection.LEFT));
		moveMapping.put("leftE", new Move(SpinDirection.LEFT));
		moveMapping.put("leftSE", new Move(SpinDirection.LEFT));
		moveMapping.put("leftS", new Move(SpinDirection.LEFT));
		moveMapping.put("leftSW", new Move(SpinDirection.LEFT));
		moveMapping.put("leftW", new Move(SpinDirection.LEFT));
		moveMapping.put("leftNW", new Move(SpinDirection.LEFT));
		moveMapping.put("rightN", new Move(SpinDirection.RIGHT));
		moveMapping.put("rightNE", new Move(SpinDirection.RIGHT));
		moveMapping.put("rightE", new Move(SpinDirection.RIGHT));
		moveMapping.put("rightSE", new Move(SpinDirection.RIGHT));
		moveMapping.put("rightS", new Move(SpinDirection.RIGHT));
		moveMapping.put("rightSW", new Move(SpinDirection.RIGHT));
		moveMapping.put("rightW", new Move(SpinDirection.RIGHT));
		moveMapping.put("rightNW", new Move(SpinDirection.RIGHT));
		
		spinMap = new HashMap<Integer, Direction>();
		spinMap.put(0, Direction.NORTH);
		spinMap.put(1, Direction.NORTH_EAST);
		spinMap.put(2, Direction.EAST);
		spinMap.put(3, Direction.SOUTH_EAST);
		spinMap.put(4, Direction.SOUTH);
		spinMap.put(5, Direction.SOUTH_WEST);
		spinMap.put(6, Direction.WEST);
		spinMap.put(7, Direction.NORTH_WEST);
		
	}
	
	// INITIALIZATION - COMMON ******************************************************
	
	public void initialConfigRobot(int defSpeed, int defTime, int defTurnSpeed, int defTurnTime)
	{
		this.defaultSpeed = defSpeed;
		this.defaultTime = defTime;
		this.defaultTurnSpeed = defTurnSpeed;
		this.defaultTurnTime = defTurnTime;
	}
	
	
	// INITIALIZATION - NAVIGATION **************************************************
	
	public void createMap(int x, int y)
	{
		map = new Map(x,y);
	}
		
	public void setMapElements(String elements)
	{
		map.addElementFromString(elements);
	}
	
	@Override
	protected void addSensorObservers(){ //TODO
		
		Set<ISensor<?>> sensors = Configurator.getInstance().getSensors(SensorType.DISTANCE);
		
		for(ISensor<?> sense : sensors)
		{
			DistanceSensor s = (DistanceSensor)sense;
			s.addObserver(new SensorObserver<IDistanceSensorData>(this,outEnvView,s.getPosition().getDefStringRep(), 5));
		}
		
	}
	
	// INITIALIZATION - EXPLORATION *************************************************
	
	public void initExploreMap(int startX, int startY, int mapWidth, int mapHeight)
	{
		// for debug use
		// i know the initial position referred to a well defined map
		
		// Sensing & Movements on the real world
		
		engine = new Engine(startX, startY, mapWidth, mapHeight, this, true);
		
		Explorer explorer = new Explorer(this, engine);
		explorer.startExploration();
		
		System.out.println("EXPLORATION DONE");	
	}
	
	public void initExploreMap()
	{
		//TODO
	}
	
	public void javaExplorer(int startX, int startY, String filename)
	{
		// for debug use
		// i know all the map and explore it
		
		// Sensing on the virtual map
		
		Map m = null;
		
		List<String> data = new ArrayList<String>();						
		try
		{
			InputStream fs = new FileInputStream(filename);
			InputStreamReader inpsr = new InputStreamReader(fs);
			BufferedReader br       = new BufferedReader(inpsr);
			Iterator<String> lsit   = br.lines().iterator();

			while(lsit.hasNext())
			{
				data.add(lsit.next());
			}
			br.close();
			
		} catch (Exception e)
		{
			System.out.println("QActor  ERROR " + e.getMessage());
		}
		
		for(int i=0; i<data.size(); i++)
		{
			if(i == 0)
			{
				m = Map.createMapFromPrologRep(data.get(i));
			}
			else
			{
				String s[] = data.get(i).split(" ");
				m.addElementFromString(s[1]);
			}
		}
		
		engine = new FileEngine(startX, startY, m, this, true);
		((QActorPlanUtilsDebug)planUtils).setEngine((FileEngine) engine);
		
		Explorer explorer = new Explorer(this, engine);
		explorer.startExploration();
		
		System.out.println("EXPLORATION DONE");		
	}
	
	
	// EXPLORATION MANAGEMENT **********************************************
	
/*	
	public void makeMove(String direction)
	{
		if(direction.equals("forward"))
			engine.moveForward();
		else
			engine.moveBackward();
		
		State s = engine.getState();
		
		System.out.println(s.toString());
		
		String payload = "position("+s.getX() + "," + s.getY() + ")," +
				s.getDirection().toString().toLowerCase();
		
		emit("show", "show(" + payload + ")");
	}
	
	public void turn(String spinDir)
	{
		if(spinDir.equals("doubleRight"))
			engine.turnDoubleRight();
		else
			engine.turnDoubleLeft();
		
		State s = engine.getState();
		
		System.out.println(s.toString());
		
		String payload = "position("+s.getX() + "," + s.getY() + ")," +
				s.getDirection().toString().toLowerCase();
		
		emit("show", "show(" + payload + ")");
	}
	
	public void addCurrentToVisited()
	{
		engine.addCurrentToVisited();
	}
	
	public boolean checkCurrentAlreadyVisited()
	{
		return engine.isCurrentAlreadyVisited();
	}	
	
	public boolean checkLeftVisited()
	{
		return engine.checkExploredLeft();
	}	
	
	public void updateModel(String dir, String state)
	{
		State next = engine.checkAndUpdate(dir, state);
		
		this.newCellX = next.getX();
		this.newCellY = next.getY();
		
		//return "position("+next.getX()+","+next.getY()+")";
	}
	
	public int getNewCellX()
	{
		return newCellX;
	}
	
	public int getNewCellY()
	{
		return newCellY;
	}
	
*/	

	//GUI INTERACTION **************************************************
	
	public void showPathOnGui()
	{
		for(State s : path)
		{
			System.out.println(s.toString());
		}
	}
	
	
	// NAVIGATION MANAGEMENT ****************************************************
	
	public void setNavigationPlan(String planName, String algo, String plan, int s, int t)
	{
		//NB: rotation step is 45 degrees
		
		String speed = ""+s;
		String time = ""+t;
		String diagoTime = ""+(Math.round(t*1.414));
		
		plan = plan.split("\\[")[1];
		plan = plan.split("\\]")[0];
		
		println("Salvataggio piano in corso");
		println(plan);
		println(speed);
		println(time);
		
		Plan pathPlan = new Plan("path");
		
		pathPlan.addPrint("Inizio Navigazione");
		
		String[] moves = plan.split(",");
		
		for(String m : moves)
		{
			switch(m)
			{
			case "t":
				pathPlan.addSenseEvent(1000, "obstacle", "waitAndEvaluate");
				pathPlan.addForwardMove(speed, time);
				break;
				
			case "d":
				pathPlan.addSenseEvent(1000, "obstacle", "waitAndEvaluate");
				pathPlan.addForwardMove(speed, diagoTime);
				break;
				
			case "l":
				pathPlan.addSpinMove(speed, time, PlanSpinDirection.LEFT);
				break;
				
			case "r":
				pathPlan.addSpinMove(speed, time, PlanSpinDirection.RIGHT);
				break;
				
			case "dl":
				pathPlan.addSpinMove(speed, time, PlanSpinDirection.LEFT);
				pathPlan.addSpinMove(speed, time, PlanSpinDirection.LEFT);
				break;
				
			case "dr":
				pathPlan.addSpinMove(speed, time, PlanSpinDirection.RIGHT);
				pathPlan.addSpinMove(speed, time, PlanSpinDirection.RIGHT);
				break;
			}			
		}
		
		pathPlan.addPrint("fine Navigazione");
		pathPlan.addSolve("continueProgram", ""+0);
		
		PlanSaver planSaver = new PlanSaver(planName, PlanExtension.PLAIN_TEXT);
		planSaver.addPlan(pathPlan);
		planSaver.storePlan();
		
		
		println(planSaver.getPlans());
		println("PLAN SAVED IN "+planSaver.getFileName());		
	}
	
	public void setPosition(int sx, int sy)
	{
		this.position =	new State(sx, sy);		
		this.direction = Direction.NORTH;
		
		println(position.toString());
	}
	
	public void updateMyPosition(String move)
	{
		this.position = this.makeMove(position, moveMapping.get(move+direction.toString()));
		System.out.println(position);
	}
	
	public void notifyMyPosition()
	{
		String payload = "position("+position.getX() + "," + position.getY() + ")," +
						position.getDirection().toString().toLowerCase();
		
		emit("show", "show(" + payload + ")");
	}
	
	
	private State makeMove(State state, Move move)
	{
		State result = new State();
		
		
		if(move.getType().equals(MoveType.SPIN))
		{
			result.setX(state.getX());
			result.setY(state.getY());
			
			result.setDirection(makeSpin(state.getDirection(), move.getSpin()));
		}
		else
		{
			int x = state.getX();
			int y = state.getY();
			
			switch(state.getDirection())
			{
			case NORTH:
				result.setX(x);
				result.setY(y-1);
				break;
			
			case NORTH_EAST:
				result.setX(x+1);
				result.setY(y-1);
				break;
				
			case EAST:
				result.setX(x+1);
				result.setY(y);
				break;
				
			case SOUTH_EAST:
				result.setX(x+1);
				result.setY(y+1);
				break;
				
			case SOUTH:
				result.setX(x);
				result.setY(y+1);
				break;
				
			case SOUTH_WEST:
				result.setX(x-1);
				result.setY(y+1);
				break;
				
			case WEST:
				result.setX(x-1);
				result.setY(y);
				break;
				
			case NORTH_WEST:
				result.setX(x-1);
				result.setY(y-1);
				break;
				
			default:
				break;
			}
			
			result.setDirection(state.getDirection());
		}
		return result;
	}
	
	public Direction makeSpin(Direction start, SpinDirection spin) {
		int newID = (start.getValue() + (8+spinFactor*spin.getRotation()))%8;
		return spinMap.get(newID);
	}
	

	// SYSTEM INTERACTION *****************************************************
	
	public void enableDebugSensing()
	{
		((QActorPlanUtilsDebug) planUtils).enableFileSensingMode();
	}
	
	public void disableDebugSensing()
	{
		((QActorPlanUtilsDebug) planUtils).disableFileSensingMode();
	}
	
	public void raiseEvent(String eventName, String payload)
	{
		emit(eventName, payload);
	}

	public IEventItem senseEvent(int timeout, String event, String plan)
	{
		setCurrentEvent(null);
		try
		{			
			AsynchActionResult aar1 =
					planUtils.senseEvents( timeout , event, plan, "" , "",ActionExecMode.synch );
			
			if( ! aar.getGoon() || aar.getTimeRemained() <= 0 )
			{
    			println("WARNING: sense timeout");
    			addRule("tout(senseevent,"+getName()+")");
    		}	
			
			return currentEvent;
		}
		catch (Exception e) {
			
			e.printStackTrace();
		}
		
		return null;
	    		
	}
	
	public void sendDispatch(String msgName, String paramsList, String destActor)
	{
		String payload = msgName+"(";
		
		paramsList = paramsList.replace("[", "");
		paramsList = paramsList.replace("]", "");
		payload += paramsList;
		
		payload += ")";
		
		try
		{
			sendMsg(msgName, destActor, QActorContext.dispatch, payload );
		} catch (Exception e)
		{
			e.printStackTrace();
		}
		
		
	}
	
	public void receiveMessageAndSolve(int timeout,
										String msgList,
										String msgPayloadList,
										String goalList,
										int solveTime)
	{
		
		try
		{
			AsynchActionResult aar = planUtils.receiveAMsg(mysupport, timeout, "" , "" ); 	//could block
			
			if( aar.getInterrupted() )
			{
			
				curPlanInExec   = "playTheGame";
				
				if( ! aar.getGoon() ) return;
			} 			
			if( ! aar.getGoon() )
			{
				System.out.println("WARNING: receiveMsg in " + getName() + " TOUT " + aar.getTimeRemained() + "/" +  timeout);
				addRule("tout(receive,"+getName()+")");
			}
			
			printCurrentMessage(false);
			
			msgList = msgList.replace("[", "");
			msgList = msgList.replace("]", "");
			
			msgPayloadList = msgPayloadList.replace("[", "");
			msgPayloadList = msgPayloadList.replace("]", "");
			
			goalList = goalList.replace("[", "");
			goalList = goalList.replace("]", "");
			
			String[] msg = msgList.split(",");
			String[] msgPayload = msgPayloadList.split(",");
			String[] goal = goalList.split(",");
			
			for(int i=0; i<msg.length; i++)
			{
				if(currentMessage.msgId().equals(msg[i]))
				{
					String parg = goal[i];
					parg = updateVars(Term.createTerm(msgPayload[i]), Term.createTerm(msgPayload[i]), 
		  					Term.createTerm(currentMessage.msgContent()), parg);
					
					if( parg != null ) {
    					aar = solveGoalReactive( parg , solveTime, "" , "");
    								
    					if( aar.getResult().equals("failure")){
    						if( ! planUtils.switchToPlan("prologFailure").getGoon() ) return;
    					}else if( ! aar.getGoon() ) return;
    				}
				}
			}
			
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		
		
	}
	
	// REAL ROBOT CONTROLS *****************************************************
	
	public void moveForward()
	{
		try
		{
			execute("forward", defaultSpeed, 0, defaultTime, "", "");
		}
		catch (Exception e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void moveBackward()
	{
		try
		{
			execute("backward", defaultSpeed, 0, defaultTime, "", "");
		}
		catch (Exception e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void turnLeft()
	{
		try
		{
			execute("left", defaultTurnSpeed, 0, defaultTurnTime, "", "");
		}
		catch (Exception e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void turnRight()
	{
		try
		{
			execute("right", defaultTurnSpeed, 0, defaultTurnTime, "", "");
		}
		catch (Exception e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
