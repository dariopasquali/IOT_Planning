/* Generated by AN DISI Unibo */ 
/*
This code is generated only ONCE
*/
package it.unibo.console;

import java.awt.Point;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import it.unibo.domain.graph.Graph;
import it.unibo.domain.graph.State;
import it.unibo.domain.model.conditional.Check;
import it.unibo.domain.model.conditional.Move;
import it.unibo.execution.domain.CMove;
import it.unibo.execution.enums.SpinAngle;
import it.unibo.gui.ConditionalPlannerGUI;
import it.unibo.is.interfaces.IActivity;
import it.unibo.is.interfaces.IIntent;
import it.unibo.is.interfaces.IOutputEnvView;
import it.unibo.model.interfaces.IMap;
import it.unibo.model.map.Map;
import it.unibo.planning.ConditionalPlanNode;
import it.unibo.planning.Plan;
import it.unibo.planning.algo.Planner;
import it.unibo.qactors.QActorContext;
import it.unibo.qactors.QActorUtils;
import it.unibo.utils.HeuristicEvaluator;
import it.unibo.model.interfaces.IGUI;

/**
 * @author Dario
 *
 */
public class Console extends AbstractConsole implements IActivity{ 
	
	public static final String MODE_WITH_OBJECTS = "objects", MODE_ONLY_BORDERS = "clear";
	
	private IMap map;
	private static ConditionalPlannerGUI env = new ConditionalPlannerGUI();
	private int sx, sy, gx, gy;
	private String filename;
	private String robotMode;
	
	private Plan plan;
	private List<ConditionalPlanNode> conditionalPlan;
	private List<CMove> expandedConditionalPlan;
	
	private long planningTime = 0L;
	
	public Console(String actorId, QActorContext myCtx, IOutputEnvView outEnvView )  throws Exception
	{
		super(actorId, myCtx, env);
		((IGUI) env).setController(this);
		env.setEnvVisible(true);
	}
	
//{{ NAVIGATION METHODS -------------------------------------------------
		
	/**
	 * Find the best path from a START position to a GOAL position.
	 * 
	 * @param sx  x coordinate of START state
	 * @param sy  y coordinate of START state
	 * @param gx  x coordinate of GOAL state
	 * @param gy  y coordinate of GOAL state
	 */
	public void createPlan(int sx, int sy, int gx, int gy, String mode)
	{		
		println("start plan creation");
		
		this.sx = sx;
		this.sy = sy;
		this.gx = gx;
		this.gy = gy;
			
		Graph graph = null;
		
		IMap forHeuristic = null;
		
		if(mode.equals(MODE_WITH_OBJECTS))
		{
			graph = getPOPGraph(map.getIntMap(), map.getXmax(), map.getYmax());
		}
		
		else
		{
			graph = getPOPGraphNoObjects(map.getNoObjects(), map.getXmax(), map.getYmax());
			forHeuristic = new Map(map.getYmax(), map.getXmax(), map.getNoObjects());
		}
		
		Planner planner = new Planner(new State(sx, sy), new State(gx, gy), graph, new HeuristicEvaluator(forHeuristic));
		
		try
		{
			long start = System.currentTimeMillis();			
			plan = planner.findPlan();			
			planningTime = System.currentTimeMillis() - start;
			
			conditionalPlan = plan.numbering();
			expandedConditionalPlan = Plan.expandPlan(conditionalPlan, SpinAngle.d90);
			
		}
		catch (Exception e) 
		{
			e.printStackTrace();
		}
	}
	
	private Graph getPOPGraph(Integer[][] intmap, int xmax, int ymax) {

		String graph = "";
		String moves = "";
		
		Graph g = new Graph();
		
		for(int x=0; x< xmax; x++)
		{
			for(int y=0; y<ymax; y++)
			{
				if(intmap[y][x] == 0)
					g.addState(new State(x,y));
			}
		}				
		
		for(int y=0; y<ymax; y++)
		{
			for(int i=0; i<(xmax-1); i++)
			{
				if(intmap[y][i] == 0 && intmap[y][i+1] == 0)
				{
					State a = new State(i, y);
					State b = new State(i+1, y);
					
					g.addState(a);
					g.addState(b);
					
					Move m = new Move(a, b);										
					g.addMove(m);				
					m = new Move(b, a);					
					g.addMove(m);
					
					Check ch = new Check(a, b);										
					g.addCheck(ch);				
					ch = new Check(b, a);					
					g.addCheck(ch);					
				}
			}
		}
		
		
		for(int x=0; x<xmax; x++)
		{
			for(int j=0; j<(ymax-1); j++)
			{
				if(intmap[j][x] == 0 && intmap[j+1][x] == 0)
				{
					State a = new State(x, j);
					State b = new State(x, j+1);
					
					g.addConnection(a.toString(), b.toString());
					g.addConnection(b.toString(), a.toString());
					
					Move m = new Move(a, b);										
					g.addMove(m);				
					m = new Move(b, a);					
					g.addMove(m);
					
					Check ch = new Check(a, b);										
					g.addCheck(ch);				
					ch = new Check(b, a);					
					g.addCheck(ch);
					
		
				}
			}
		}		
		
		return g;
	}
	
	private Graph getPOPGraphNoObjects(Integer[][] intmap, int xmax, int ymax) {

		Graph g = new Graph();
		
		for(int x=0; x< xmax; x++)
		{
			for(int y=0; y<ymax; y++)
			{
				if(intmap[y][x] == 0)
					g.addState(new State(x,y));
			}
		}				
		
		for(int y=0; y<ymax; y++)
		{
			for(int i=0; i<(xmax-1); i++)
			{
//				if(intmap[y][i] == 0 && intmap[y][i+1] == 0)
//				{
					State a = new State(i, y);
					State b = new State(i+1, y);
					
					g.addState(a);
					g.addState(b);
					
					Move m = new Move(a, b);										
					g.addMove(m);				
					m = new Move(b, a);					
					g.addMove(m);
					
					Check ch = new Check(a, b);										
					g.addCheck(ch);				
					ch = new Check(b, a);					
					g.addCheck(ch);					
//				}
			}
		}
		
		
		for(int x=0; x<xmax; x++)
		{
			for(int j=0; j<(ymax-1); j++)
			{
//				if(intmap[j][x] == 0 && intmap[j+1][x] == 0)
//				{
					State a = new State(x, j);
					State b = new State(x, j+1);
					
					g.addConnection(a.toString(), b.toString());
					g.addConnection(b.toString(), a.toString());
					
					Move m = new Move(a, b);										
					g.addMove(m);				
					m = new Move(b, a);					
					g.addMove(m);
					
					Check ch = new Check(a, b);										
					g.addCheck(ch);				
					ch = new Check(b, a);					
					g.addCheck(ch);
					
		
//				}
			}
		}		
		
		return g;
	}
	
	
	/**
	 * @return  the plan as a prolog list of moves
	 */
	private String getPrologPlan()
	{
		String moves = "plan([";
		for(int i=0; i<expandedConditionalPlan.size(); i++)
		{
			moves += expandedConditionalPlan.get(i).getPrologRep();
			if(i!=expandedConditionalPlan.size()-1)
				moves+=",";
		}
		moves+="])";
		//println(moves);
		return moves;
	}

	
	/**
	 * @return  the START position in a prolog representation
	 */
	private String getPrologPosition()
	{
		return "position( "+sx+", "+sy+" )";		
	}

	
	/**
	 * Send plan, START position and, eventually filename, to the Robot
	 */
	public void sendNavigationData(){
		sendNavigationData(robotMode);
	}
		
	/**
	 * Send plan, START position and, eventually filename, to the Robot
	 * 
	 * @param mode  simulated or real Robot
	 */
	public void sendNavigationData(String mode)
	{	
		String pp = getPrologPlan();
		String po = getPrologPosition();
		this.robotMode = mode;
			
		println(pp);
		println(po);
		println(mode);
			
		if(mode.equals("robot"))
		{
			temporaryStr = QActorUtils.unifyMsgContent(pengine, "navigate(PLAN,POS)","navigate("+pp+","+po+")", guardVars ).toString();
			println("temp string "+temporaryStr);
			try
			{
				sendMsg("navigate","robot", QActorContext.dispatch, temporaryStr );
			} catch (Exception e)
			{
				e.printStackTrace();
			}
		}
		else
		{
			temporaryStr = QActorUtils.unifyMsgContent(pengine, "navigatefile(PLAN,POS,FILENAME)","navigatefile("+pp+","+po+",\""+filename+"\")", guardVars ).toString();
			println("temp string "+temporaryStr);
			try
			{
				sendMsg("navigatefile","robot", QActorContext.dispatch, temporaryStr );
			} catch (Exception e)
			{
				e.printStackTrace();
			}
		}
			
				
	}

//}}	
	
	
//{{ GUI INTERACTION ---------------------------------------------------
	
	/**
	 * Load the map from the Prolog file and show it on GUI as a Button Matrix.
	 * 
	 * @param path  absolute filepath of the map
	 */
	public void loadMapButton(String path)
	{	
		Map m = null;
		List<String> data = new ArrayList<String>();						
		try
		{
			InputStream fs = new FileInputStream(path);
			InputStreamReader inpsr = new InputStreamReader(fs);
			BufferedReader br       = new BufferedReader(inpsr);
			Iterator<String> lsit   = br.lines().iterator();

		while(lsit.hasNext())
		{
			data.add(lsit.next());
		}
		br.close();
			
		} catch (Exception e)
		{
			System.out.println("QActor  ERROR " + e.getMessage());
		}
				
		for(int i=0; i<data.size(); i++)
		{
			if(i == 0)
			{
				m = Map.createMapFromPrologRep(data.get(i));
			}
			else
			{
				String s[] = data.get(i).split(" ");
				m.addElementFromString(s[1]);
			}
		}
		this.map = m;
			
		
		((ConditionalPlannerGUI)env).setMap(m);
		this.filename = path; 
			
	}
	
	public void savePlan(String path)
	{
		String head = "/*"
				+ "\n*"
				+ "\n* A GraphViz DOT FSM description"
				+ "\n* Please use a GraphViz visualizer (like http://www.webgraphviz.com)"
				+ "\n*"
				+ "\n* Generated by DP"
				+ "\n*"
				+ "\n*/";
		
		String numbered = "";
		for(ConditionalPlanNode n : plan.numbering())
			numbered += n.toString()+"\n";
		
		String graphviz = head + "\n\n\n" + plan.getGraphvizRepresentation();
		
		
		try
		{
			FileOutputStream fsout = new FileOutputStream( new File(path+".txt") );
			fsout.write(numbered.getBytes());
			fsout.close();		
			
			fsout = new FileOutputStream( new File(path+".gviz") );
			fsout.write(graphviz.getBytes());
			fsout.close();
			
		} catch (Exception e) {
			e.printStackTrace();
 		}
	}

	public void showPlan() {

		if(plan == null)
		{
			println("ERROR! plan is NULL");
			return;
		}
		
		println("\n---------------------------\n");
		println("CONDITIONAL PLAN");
		
		for(ConditionalPlanNode n : conditionalPlan)
			println(n.toString());		
		
		println("\n\n---------------------------\n");
		println("EXPANDED PLAN");
		
		for(CMove n : expandedConditionalPlan)
			println(n.toString());	
		
		println("\n\n---------------------------\n");
		println("PLANNING TIME ---> "+planningTime);
		
	}
	
//}}
	
	/* (non-Javadoc)
	 * @see it.unibo.is.interfaces.IActivityBase#execAction(java.lang.String)
	 */
	@Override
	public void execAction(String cmd) {
		
		String[] command = cmd.split(" ");		
		String[] params;
		switch (command[0]){
			
		case "LOAD":
			emit( "local_gui_command", "local_gui_command(loadmap(\""+command[1]+"\"))");
			break;
			
		case "STORE":
			emit( "local_gui_command", "local_gui_command(saveplan(\""+command[1]+"\"))");
			break;
				
		case "NAVIGATE":
			emit( "local_gui_command", "local_gui_command(navigate("+command[1]+"))");
			break;
				
		case "CREATE":
			params = command[1].split(",");
			
			emit( "local_gui_command", "local_gui_command(createplan("
						+ "position(" + params[0] + "," + params[1]+")"
								+ ","
						+ "position(" + params[2] + "," + params[3]+")," + params[4] 
								+ ")");
						
			break;		
				
		default:
			println("Invalid command");
		}
	}


	@Override
	public void execAction() {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void execAction(IIntent input) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public String execActionWithAnswer(String cmd) {
		// TODO Auto-generated method stub
		return null;
	}	
}
